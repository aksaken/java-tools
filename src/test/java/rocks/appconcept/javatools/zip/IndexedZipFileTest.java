package rocks.appconcept.javatools.zip;

import rocks.appconcept.javatools.binary.ByteArrayFinder;
import rocks.appconcept.javatools.file.FileUtils;
import rocks.appconcept.javatools.io.StreamUtils;
import junit.framework.TestCase;

import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

/**
 * @author yanimetaxas
 */
public class IndexedZipFileTest extends TestCase {

    byte rawData[] = {
            0x50, 0x4B, 0x03, 0x04, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xF0, 0x63,
            (byte) 0x90, 0x46, (byte) 0x8B, 0x73, (byte) 0x95, (byte) 0xAC, 0x09, 0x00, 0x00, 0x00, 0x09, 0x00,
            0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x68, 0x65, 0x6C, 0x6C, 0x6F, 0x2E,
            0x74, 0x78, 0x74, 0x68, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x7A, 0x69, 0x70,
            0x50, 0x4B, 0x01, 0x02, 0x3F, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00,
            (byte) 0xF0, 0x63, (byte) 0x90, 0x46, (byte) 0x8B, 0x73, (byte) 0x95, (byte) 0xAC, 0x09, 0x00, 0x00, 0x00,
            0x09, 0x00, 0x00, 0x00, 0x09, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x65,
            0x6C, 0x6C, 0x6F, 0x2E, 0x74, 0x78, 0x74, 0x0A, 0x00, 0x20, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x3E, 0x47, 0x60, (byte) 0x80, 0x30,
            0x78, (byte) 0xD0, 0x01, 0x66, 0x1F, 0x5B, 0x2E, 0x30, 0x78, (byte) 0xD0, 0x01, 0x66,
            0x1F, 0x5B, 0x2E, 0x30, 0x78, (byte) 0xD0, 0x01, 0x50, 0x4B, 0x05, 0x06, 0x00,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x5B, 0x00, 0x00, 0x00, 0x30,
            0x00, 0x00, 0x00, 0x00, 0x00
    };

    public void testHappyPath() throws Exception {

        IndexedZipFile indexedZipFile = new IndexedZipFile(rawData);

        Collection<String> fileNames = indexedZipFile.getFileNames();
        assertTrue(fileNames.contains("hello.txt"));

        int size = indexedZipFile.getSize("hello.txt");
        assertEquals(9, size);

        InputStream inputStream = indexedZipFile.getInputStream("hello.txt");
        byte[] buffer = new byte[9];
        int read = inputStream.read(buffer);
        assertEquals(9, read);
        inputStream.close();
        assertEquals("hello zip", new String(buffer, StandardCharsets.UTF_8));
    }

    public void testMessageDigester() throws Exception {

        IndexedZipFile indexedZipFile = new IndexedZipFile(rawData);

        MessageDigest md5;
        byte[] digest;

        md5 = MessageDigest.getInstance("MD5");
        indexedZipFile.updateMessageDigest(md5, null);
        digest = md5.digest();
        assertTrue(Arrays.equals(new byte[]{-108, -65, -99, 37, -58, 106, 97, -113, -51, 20, 99, -94, -110, 26, -20, 22}, digest));

        md5 = MessageDigest.getInstance("MD5");
        indexedZipFile.updateMessageDigest(md5, Collections.singletonList("hello.txt"));
        digest = md5.digest();
        assertTrue(Arrays.equals(new byte[]{-44, 29, -116, -39, -113, 0, -78, 4, -23, -128, 9, -104, -20, -8, 66, 126}, digest));
    }

    public void testUnicodeFilenames() throws Exception {

        byte[] unicode = {
                0x50, 0x4B, 0x03, 0x04, 0x0A, 0x00, 0x00, 0x08, 0x00, 0x00, (byte) 0xB4, 0x44,
                (byte) 0x98, 0x46, 0x2E, 0x54, 0x68, 0x0C, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00,
                0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x6B, 0x6F, 0x6E, 0x73, 0x74, 0x69,
                0x67, (byte) 0xDB, (byte) 0x9E, 0x2E, 0x74, 0x78, 0x74, 0x68, 0x65, 0x6A, 0x50, 0x4B,
                0x01, 0x02, 0x3F, 0x00, 0x0A, 0x00, 0x00, 0x08, 0x00, 0x00, (byte) 0xB4, 0x44,
                (byte) 0x98, 0x46, 0x2E, 0x54, 0x68, 0x0C, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00,
                0x00, 0x00, 0x0D, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6B, 0x6F, 0x6E, 0x73,
                0x74, 0x69, 0x67, (byte) 0xDB, (byte) 0x9E, 0x2E, 0x74, 0x78, 0x74, 0x0A, 0x00, 0x20,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x01, (byte) 0x8A, 0x44,
                0x28, 0x59, 0x7E, (byte) 0xD0, 0x01, 0x49, 0x00, (byte) 0xEB, (byte) 0xF7, 0x58, 0x7E, (byte) 0xD0,
                0x01, 0x49, 0x00, (byte) 0xEB, (byte) 0xF7, 0x58, 0x7E, (byte) 0xD0, 0x01, 0x50, 0x4B, 0x05,
                0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x5F, 0x00, 0x00,
                0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00
        };

        IndexedZipFile zipFile = new IndexedZipFile(unicode);
        String unicodename = zipFile.getFileNames().iterator().next();
        assertEquals("konstig\u06de.txt", unicodename);
    }

    public void testDeflatedEntries() throws Exception {
        byte[] zipfile = {
                0x50, 0x4B, 0x03, 0x04, 0x14, 0x00, 0x00, 0x00, 0x08, 0x00, 0x37, 0x45,
                (byte) 0x98, 0x46, (byte) 0xD9, (byte) 0x82, 0x6A, (byte) 0xB8, 0x14, 0x00, 0x00, 0x00, (byte) 0xB0, 0x0A,
                0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x61, 0x2E, 0x74, 0x78, 0x74, (byte) 0xED,
                (byte) 0xC1, 0x31, 0x01, 0x00, 0x00, 0x00, (byte) 0xC2, (byte) 0xA0, (byte) 0xAC, (byte) 0xF6, 0x2F, 0x61,
                (byte) 0x8D, 0x1D, (byte) 0xC0, 0x00, 0x00, 0x20, (byte) 0xEC, 0x50, 0x4B, 0x01, 0x02, 0x3F,
                0x00, 0x14, 0x00, 0x00, 0x00, 0x08, 0x00, 0x37, 0x45, (byte) 0x98, 0x46, (byte) 0xD9,
                (byte) 0x82, 0x6A, (byte) 0xB8, 0x14, 0x00, 0x00, 0x00, (byte) 0xB0, 0x0A, 0x00, 0x00, 0x05,
                0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0x2E, 0x74, 0x78, 0x74, 0x0A, 0x00,
                0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00, (byte) 0xB2, 0x57,
                0x3E, (byte) 0xBB, 0x59, 0x7E, (byte) 0xD0, 0x01, (byte) 0xBF, 0x45, (byte) 0xD6, (byte) 0xB2, 0x59, 0x7E,
                (byte) 0xD0, 0x01, (byte) 0xBF, 0x45, (byte) 0xD6, (byte) 0xB2, 0x59, 0x7E, (byte) 0xD0, 0x01, 0x50, 0x4B,
                0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x57, 0x00,
                0x00, 0x00, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00
        };
        IndexedZipFile zip = new IndexedZipFile(zipfile);

        InputStream inputStream = zip.getInputStream("a.txt");
        byte[] as = new byte[2736];
        int read = inputStream.read(as);
        assertEquals(2736, read);
        for (byte a : as) {
            assertEquals((byte) 'a', a);
        }
    }

    public void testEmptyInputStream() throws Exception {
        byte[] withempty = {
                0x50, 0x4B, 0x03, 0x04, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xEA, 0x45,
                (byte) 0x98, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x2D,
                0x66, 0x69, 0x6C, 0x65, 0x2E, 0x74, 0x78, 0x74, 0x50, 0x4B, 0x01, 0x02,
                0x3F, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xEA, 0x45, (byte) 0x98, 0x46,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x0E, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x2D,
                0x66, 0x69, 0x6C, 0x65, 0x2E, 0x74, 0x78, 0x74, 0x0A, 0x00, 0x20, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x65, (byte) 0xFC, 0x7E, (byte) 0x82,
                0x5A, 0x7E, (byte) 0xD0, 0x01, 0x65, (byte) 0xFC, 0x7E, (byte) 0x82, 0x5A, 0x7E, (byte) 0xD0, 0x01,
                0x65, (byte) 0xFC, 0x7E, (byte) 0x82, 0x5A, 0x7E, (byte) 0xD0, 0x01, 0x50, 0x4B, 0x05, 0x06,
                0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x60, 0x00, 0x00, 0x00,
                0x2C, 0x00, 0x00, 0x00, 0x00, 0x00
        };

        IndexedZipFile zip = new IndexedZipFile(withempty);
        InputStream empty = zip.getInputStream("empty-file.txt");
        assertEquals(-1, empty.read());
        assertEquals(-1, empty.read(new byte[100]));
        assertEquals(-1, empty.read(new byte[100], 0, 100));
        assertEquals(0, empty.skip(1000));
        assertEquals(0, empty.available());
        empty.close();
        empty.mark(100);
        empty.reset();
        assertFalse(empty.markSupported());
    }

    public void testInvalidZipFile() throws Exception {
        try {
            new IndexedZipFile(new byte[100]);
            fail();
        } catch (IllegalArgumentException ignored) {
        }
    }

    public void testUnknownCompressionMethod() throws Exception {
        byte[] rawData = {
                0x50, 0x4B, 0x03, 0x04, 0x3F, 0x00, 0x00, 0x00, 0x0E, 0x00, (byte) 0xD8, 0x46,
                (byte) 0x98, 0x46, 0x50, 0x1D, 0x66, (byte) 0x81, 0x1E, 0x00, 0x00, 0x00, (byte) 0xF0, 0x06,
                0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x62, 0x6F, 0x72, 0x6B, 0x2E, 0x74,
                0x78, 0x74, 0x09, 0x14, 0x05, 0x00, 0x5D, 0x00, 0x00, 0x00, 0x04, 0x00,
                0x31, 0x1B, (byte) 0xCA, (byte) 0xAB, 0x6A, (byte) 0xC0, 0x13, 0x5B, (byte) 0xB5, (byte) 0x8A, (byte) 0xD2, (byte) 0xA3,
                0x70, (byte) 0xDF, 0x53, 0x76, (byte) 0x8E, (byte) 0xD5, (byte) 0x84, 0x00, 0x50, 0x4B, 0x01, 0x02,
                0x3F, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x0E, 0x00, (byte) 0xD8, 0x46, (byte) 0x98, 0x46,
                0x50, 0x1D, 0x66, (byte) 0x81, 0x1E, 0x00, 0x00, 0x00, (byte) 0xF0, 0x06, 0x00, 0x00,
                0x08, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x6F, 0x72, 0x6B, 0x2E, 0x74,
                0x78, 0x74, 0x0A, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
                0x18, 0x00, (byte) 0x89, 0x6E, 0x6F, (byte) 0x8D, 0x5B, 0x7E, (byte) 0xD0, 0x01, (byte) 0x9B, 0x10,
                0x4F, 0x72, 0x5B, 0x7E, (byte) 0xD0, 0x01, (byte) 0x9B, 0x10, 0x4F, 0x72, 0x5B, 0x7E,
                (byte) 0xD0, 0x01, 0x50, 0x4B, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
                0x01, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00
        };

        IndexedZipFile zip = new IndexedZipFile(rawData);
        try {
            zip.getInputStream("bork.txt");
            fail();
        } catch (IllegalArgumentException ignored) {
        }
    }

    public void testInternalsOfZeroPaddedInputStream() throws Exception {

        byte[] bytes = "aaaaaaaaaa".getBytes(StandardCharsets.UTF_8);
        assertEquals(10, bytes.length);
        {
            Class<?> aClass = IndexedZipFile.class.getClassLoader().loadClass("rocks.appconcept.javatools.zip.IndexedZipFile$ZeroPaddedByteArrayInputStream");
            InputStream zeropadded = (InputStream) aClass.getConstructors()[0].newInstance(bytes, 0, 10);
            for (int i = 0; i < 10; i++) {
                assertEquals('a', zeropadded.read());
            }
            assertEquals(0, zeropadded.read());
        }
        {
            Class<?> aClass = IndexedZipFile.class.getClassLoader().loadClass("rocks.appconcept.javatools.zip.IndexedZipFile$ZeroPaddedByteArrayInputStream");
            InputStream zeropadded = (InputStream) aClass.getConstructors()[0].newInstance(bytes, 0, 10);
            byte[] b = FileUtils.readFully(zeropadded);
            assertEquals(11, b.length);
            assertEquals(-1, zeropadded.read());
        }
        {
            Class<?> aClass = IndexedZipFile.class.getClassLoader().loadClass("rocks.appconcept.javatools.zip.IndexedZipFile$ZeroPaddedByteArrayInputStream");
            InputStream zeropadded = (InputStream) aClass.getConstructors()[0].newInstance(bytes, 0, 10);
            byte[] b = new byte[100];
            Arrays.fill(b, (byte) 1);
            int read = 0;
            do {
                read += zeropadded.read(b, 50 + read, 11 - read);
            } while (read < 11);

            for (int i = 0; i < 10; i++) {
                assertEquals('a', b[50 + i]);
            }
            assertEquals(0, b[50 + 10]);
            assertEquals(-1, zeropadded.read());
        }
        {
            Class<?> aClass = IndexedZipFile.class.getClassLoader().loadClass("rocks.appconcept.javatools.zip.IndexedZipFile$ZeroPaddedByteArrayInputStream");
            InputStream zeropadded = (InputStream) aClass.getConstructors()[0].newInstance(bytes, 0, 10);
            assertEquals(5, zeropadded.skip(5));
            byte[] b = FileUtils.readFully(zeropadded);
            assertEquals(11 - 5, b.length);
            assertEquals(-1, zeropadded.read());
        }
    }

    public void testFilenameEncodings() throws Exception {
        final String filename = "hello\ufffe\u0FFE\u00FEthere";
        byte[] b = StreamUtils.captureBytes(s -> {
            ZipOutputStream zos = new ZipOutputStream(s, StandardCharsets.UTF_8);
            zos.putNextEntry(new ZipEntry(filename));
            zos.write("apa".getBytes());
            zos.closeEntry();
            zos.flush();
            zos.close();
        });
        IndexedZipFile indexedZipFile = new IndexedZipFile(b);
        String next = indexedZipFile.getFileNames().iterator().next();
        assertEquals(filename, next);

        List<Integer> allIndexes = ByteArrayFinder.findAllIndexes(filename.getBytes(StandardCharsets.UTF_8), b);
        assertEquals(2, allIndexes.size());
        int index = allIndexes.get(1);

        try {
            b[index + 1] = (byte) 0b11000000;
            b[index + 2] = (byte) 0b11111111;
            new IndexedZipFile(b);
            fail("Invalid encoding should fail");
        } catch (IllegalArgumentException ignored) {
        }

        try {
            b[index + 1] = (byte) 0b11100000;
            b[index + 2] = (byte) 0b11111111;
            new IndexedZipFile(b);
            fail("Invalid encoding should fail");
        } catch (IllegalArgumentException ignored) {
        }

        try {
            b[index + 1] = (byte) 0b10000000;
            b[index + 2] = (byte) 0b11111111;
            new IndexedZipFile(b);
            fail("Invalid encoding should fail");
        } catch (IllegalArgumentException ignored) {
        }
    }
}